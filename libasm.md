# Assembly





# 어셈블리어는 무엇인가

기계어들이 이해할 수 있는 언어. 즉, cpu가 이해할 수 있는 언어. 0과 1이라는 전기 신호이다.



ex)

x = 10 + 2

y = x + 4



그런데 이 기계어는 읽기가 너무 불편하다. 그래서 이것을 좀더 인간친화적으로 읽기 쉽게 표현한 것이 바로 어셈블리어 이다. 

그리고 `기계어를 어셈블리어로` 바꿔주는 작업을 수행하는 녀석이 어셈블러(Assembler)이다.



<br>



## 어셈블러의 종류

어셈블러의 종류에는 nasm도 있고 masm도 있고 GNU Assembler(GAS)라는 것도 있다.



<br>



# 환경설정

어셈블리어는 명령어 모음과 프로세서의 아키텍쳐에 의존적이다. 

필자의 설명은 모두 intel-32 문법을 기반으로 진행할 것이다. Intel-32와 함께 AT&T라는 문법도 있다.



<br>



어셈블러는 NASM을 사용하기로 한다.



<br>



## NASM 설치



# 레지스터

어셈블리어로 프로그래밍을 하기 위해서는 c언어와 같이 상대적으로 고급스러운 언어와는 달리 CPU 내부에 있는 특별한 메모리에 대해서도 알고 있어야 한다. 

우리가 일반적으로 알고 있는 CPU 내부에는 `Register레지스터`라고 불리는 특별한 메모리가 있다. 



<br>



레지스터는 CPU가 접근할 수 있는 메모리 중에서 가장 빠르게 동작하는 메모리이다. CPU가 여러 연산들을 처리하는 동안 필요한 임시적인 데이터를 보관하는 데에 사용한다. 연산은 레지스터에서 처리하고, 데이터를 읽거나 쓰는 것은 RAM에서 처리한다.



<br>



메인 메모리와의 차이점이라고 한다면 메인 메모리는 바이트 단위의 주소를 이용해서 접근해야 하는 위치를 구분하는 반면,

레지스터의 경우는 번지의 개념이 없고 모두 고유한 이름이 부여되어 있다는 점이다.



<br>



CPU에는 여러 개의 레지스터가 있고, 각각 다양한 역할을 맡고 있다. 그런데 이 때 운영체제가 사용하는 레지스터를 제외하면 일밙거인 응용프로그램이 이용할 수 있는 레지스터는 얼마 되지 않는다.



<br>



## 레지스터의 종류

### 범용 레지스터  - `RAX, EAX, AX, AH, AL`



<br>



이들 레지스터는 이름 그대로 범용 레지스터, 즉 어디든 쓸 수 있게 다양한 역할을 하는 레지스터이다. 종류로는 `RAX, RBX, RCX, RDX` 가 있다. X앞에 붙는 A,B,C,D는 단순히 구분을 위해 붙여준 것이다. 레지스터의 크기별로 RAX, EAX, AX로 나눌 수 있다. 16비트 시절에는 AX였던 것이 32비트 체제에서는 EAX로 바뀌었다. 여기서 E는 레지스터의 크기가 16비트인 시절에서 32비트로 넘어오면서 Extended 되었다는 의미에서 붙은 것이다. 64비트 체제에서는 E가 R로 바뀐다. 



<br>



#### 범용 레지스터의 구조

예를 들어

```
|□ □ □ □ |□ □ □ □ □|□ □ □ □ |□ □ □ □ |
                   <---AH--><--AL--->
                    *4비트     *4비트(최하위 1바이트)
                    <------AX------->
                           *8비트
```



<br>



위와 같은 16비트 메모리 공간이 있다 하면, 해당 공간의 8비트는 AX가 되고, AX 내에서 상위 4비트가 AH, 하위 4비트가 AL이 된다.

이 때 AH의 H는 high이고 L은 low이다.



<br>



범용 레지스터에는 RAX~RDX가 있다고 했다. 요기서 R은 빼고 A, B, C, D가 주로 사용되는 곳을 살펴보자.



<br>



**AX** 

AX는 기본 사칙연산 수행을 위한 공간이다. 



<br>



**BX**

BX는 base register로 알려져 있으며 메모리 주소를 가리키는 곳을 저장하는 데에 쓰인다.



<br>



**CX**

CX는 loop count에 수행에 필요한 공간을 저장하는 데에 사용한다.



<br>



**DX**

DX는 AX와 마찬가지로 사칙연산을 수행하는데, 큰 값의 연산에 주로 사용된다.



<br>



위에서 설명했듯 현대의 어셈블리어는 32비트 기반이므로 32개의 공간을 가진다. 그리고 EAX가 AX였던 시절, 그러니까 16비트였던 시절 자리수가 낮은 쪽과 자리수가 높은 쪽 두 개로 나누어 쓰기도 했다. 높은 쪽을 AH, 낮은 쪽을 AL로 나누어 썼다. 현재는 다음 형태의 



<br>



### EIP(RIP)

레지스터 중에는 EIP(RIP)라는 것이 있는데, 이는 현재 명령이 실행될 주소를 담는다. 디버거 프로그램을 이용해서 assembler를 실행시키는 경우 알아두면 좋다. 참고로 eip는 범용레지스터가 아니라서 명령어를 담을 수 없다.



<br>





## 메모리의 크기



어셈블리어에서는 메모리의 크기를 32비트를 기준으로 하여 4개 영역으로 나누어놓았다.

크게 byte, word, dword, qword로 나누어져 있다.



<br>



1. byte

   byte는 레지스터에서 AL에 해당한다. 1byte = 8bit이고 c언어에서의 char와 같다.

2. word

   word는 레지스터에서 AX에 해당하며 1word = 2byte = 16bit이다. c언어에서의 short 정도로 보면 된다.

3. dword

   dword는 레지스터에서 EAX에 해당하며 1dword = 2word = 4byte = 32bit이다. c언어에서의 int.

4. qword

   qword는 레지스터에서 RAX에 해당하며 1qword = 2dword = 8byte = 64bit이다. c언에서의 long.

   

 





## 포인터 레지스터



## 세그먼트 레지스터



<br>



# 주석



어셈블리어에서의 주석은 `;` 세미콜론으로 시작한다. printable한 문자라면 어떤 문자든 사용 가능하다. 

예를 들면 `; program comment asm` 이런 식으로 사용한다.



<br>



명령어와 같이 한 줄에 주석을 달 수도 있다.

ex)

```assembly
add eax, ebx	;adds ebx to eax
```



<br>





# 명령어

 어셈블리어는 명령어(instrunction 또는 opcode)와 피연산자(또는 오퍼런드operand라고 부름)로 이루어져있다.

명령어는 명령어만 있을 수도 있고 뒤에 오퍼런드가 따라 오는 구조가 있을 수 있다.

이해하기 쉽게 설명하면 다음의 구조를 띈다.

```assembly
명령어 오퍼런드1 오퍼런드2 오퍼런드3

앉아라
공부해라 어셈블리어
먹어라 사과 바나나 딸기
```



<br>



## MOV

mov는 간단하게 말해 이동시킨다는 의미이다.

예를 들어  `mov eax, 1` 이라는 명령어-피연산자 가 있다고 하자.

이 경우 해당 라인의 뜻은 eax라는 공간에 1이라는 값을 이동시켜라, 즉 담아라 라는 뜻이 된다.

(잘 보면 c언어의 함수 형태 같다. mov라는 함수의 인자로 두 개가 들어오는 것처럼.)

그리고 하나 더 특징적인 것은 뒤에 있는 값을 앞에 담는 순서라는 것이다.



<br>



### MOV로 값 넣기



<br>



mov를 통해 eax에 1을 넣어보았다.

이번에는 eax에 ebx를 넣어보자. 

```
mov eax, ebx
```



<br>



이처럼 뒤에 있는 연산자가 앞에 담기게 된다.



<br>



여기서 잠깐 확인할 것이 있다. 레지스터는 AX(하위 16비트), AH(8비트), AL(8비트)로 나뉜다고 했는데, 그럼 AH 같은 곳에 직접 값을 담을 수도 있을까?

정답은 yes이다. 

예를 들어 ECX(하위 32비트)가 다음과 같다고 하자.

```assembly
; ECX -> |00000000|0000|00|0A|
```



<br>



이 경우 CX는 0000 00 0A가 되고, CH는 00, CL은 0A가 된다.

여기에 `mov CH, 0A`를 해준다면 결과는 어떻게 될까?

답은 다음과 같다.

```assembly
mov ch, 0A
; ECX -> |00000000|0000|0A|0A
```



<br>



즉, CH, CL 등에도 직접 값을 대입할 수 있다는 것이 된다.

`주의! EAX에 CH를 넣는 것은 안 된다. operands 는 모두 공간의 크기가 같아야 한다.`



<br>



## jmp

jump의 줄임말로, 점프는 명령줄을 건너뛴다는 의미이다. 또한 어떤 지점으로 돌아간다는 의미로 사용할 수 있다.



<br>



### 사용법

`jmp 주소값` 으로 사용한다. 



다음과 같이 사용하면, eax 안에 있는 주소로 이동하게 된다.

```assembly
jmp 00401005
jmp eax
;eax가 00401005라면 00401005로 이동.
```



<br>



그래서 예를 들어 다음과 같은 어셈블리코드가 있다고 치면 eax, ebx, ecx에 0이 담기는 코드가 반복될 것이다.

```assembly
(00401000)mov eax, 0
(00401005)mov ebx, 0
(0040100A)mov ecx, 0
(0040100C)jmp 00401000 ;00401000메모리에 담긴 명령어(처음 1번 줄)로 점프.
```



<br>



## 조건 분기문 jz, je 그리고 ZF

jmp는 인자로 하나의 값(주소)을 받아 무조건 점프를 했다.

그런데 조건에 따른 점프를 하는 

그것이 바로 jz(==jzero)이다.

이것은 `zero flag가 0(zero)가 되면 점프를 하라`는 의미이다.

zero flag가 무엇인지에 대해서도 같이 배워보자.



<br>



zero flag는 이전의 명령어로 인해 무언가가 0이 되었다는 것을 의미한다.

그러니까 평상시에는 ZF(Zero Flag)가 0이다가,

다음의 코드를 만난다면

```assembly
mov eax, 1
inc eax
dec eax    ;여기까진 ZF가 0
dec eax    ;ZF == 1
```

바로 위의 명령어에서 eax가 0이 되었으므로 ZF가 1이 된다.

(단, mov eax, 0에 의해서 ZF가 1이 되지는 않는다.)



<br>



jz

이미지로 설명하기



<br>



je

je는 jump if equal로 해석하면 된다. 그런데 jz는 je랑 같다.

이게 무슨 말이냐고?

설명을 들어보면 이해가 갈 것이다.



<br>



여기서 하나 알아둬야 하는 개념이 `cmp`라는 명령어이다. 

cmp는 인자 두 개를 받아서 그것이 같으면 ZF를 1로 바꾼다.

그 원리는 cmp가 비교를 할 때 `인자1 - 인자2`를 수행하기 때문에 그 값이 같으면 0이 되는 것이다.



<br>



## jne

jne. jnz등 우리가 아는 것 안에 `n`이 들어간 명령어도 있다.

이 때의 n은 `not`이라는 뜻으로, jne는 jump not equal 이라는 뜻으로 `같지 않다`는 뜻이 된다.



<br>



## JG, JL, SF, OF, CF



JG와 JL 역시 조건분기명령어로써 JG는 `greater`, JL은 `less`가 담겨 있는 명렁어이다.

이것은 뒤에 따라오는 인자1, 인자2를 비교해(cmp) 인자1이 인자2보다 크면 점프, 그렇지 않으면 그냥 넘어간다는 것을 의미한다.

jl역시 반대의 의미에서 작용한다.

참고로 크냐 안 크냐는 `부호 있는` 2진수법을 따른다.

[부호있는/없는 2진수 참고링크](https://m.blog.naver.com/PostView.nhn?blogId=chgy2131&logNo=140186696889&proxyReferer=https:%2F%2Fwww.google.com%2F)



<br>



이 때 JG의 조건은 ZF가 0이면서 SF(Sign Flag)와 OF(Overflow Flag)가 같다는 조건에 의해 판단하게 되는데, 이것을 통해 체크를 하려고 하면 조금 어려워질 수 있다.

그래도 간단하게 알고 넘어가자면 SF는 `인자1 - 인자2` 의 결과 2진수의 맨 앞이 1이 된다는 것을 의미하고,

OF는 예를 들어 0101과 0100을 더한다는 상황을 가정하면 결과는 1001이 된다. 즉 맨 앞의 비트가 바뀌게 되는데, 이 경우 Overflow가 발생했다고 여겨서 OF = 1이 된다. 



참고로 CF(Carry Flag)라는 것도 있다. 예를 들어 1000과 1111을 더해야 하는 상황이 있다고 가정해보자.

이 경우 1 + 0111이 되어 표현할 수 없는 비트에 1을 넘겨주는 상황이 되고, 이 경우에 한해 CF = 1이 된다.



<br>



## 증감 명령어 inc, dec

inc 는 increment의 약자로 증가라는 뜻이고 dec는 반대로 감소라는 뜻이다.

inc, dec 뒤에는 메모리 또는 레지스터가 올 수 있다.



<br>



예를들어 다음의 명령어가 있다고 하자.

그렇다면 최초값 `00000000`에 대해 주석에 나와 있는 형식으로 값이 변할 것이다.

```assembly
mov eax, 0 ; eax = 00000000
inc eax    ; eax = 00000001
inc eax    ; eax = 00000002
dec eax    ; eax = 00000001
```



<br>



## 더하기 빼기 add, sub



add, sub는 Add, Subtraction 즉 더하기 빼기라는 뜻이다. 

메모리에 어떤 데이터를 더한다는 뜻으로 사용된다.

c언어로 치자면 +, - 와 같다.



<br>



```assembly
mov eax, 0    ;eax = 00000000
mov ecx, 0    ;ecx = 00000000
add eax, 10   ;여기서 10은 '십'이 아니라 '일영'으로 읽어야 한다
              ;16진수이기 때문이다.
              ;eax = 00000010
add eax, 8    ;eax = 00000018
sub eax, 3    ;eax = 00000015
add ecx, eax  ;ecx = 00000015
add ecx, 3    ;ecx = 00000018
sub ecx, eax  ;ecx = 00000003
```



<br>



## PUSH, POP, ESP, CALL, RET

우리 컴퓨터에는 stack 영역이라는 것이 있다. 

스택 영역에는 `push(or pop) + 인자`로 데이터를 넣었다 뺐다 할 수 있다.

이 때 스택의 가장 위에 있는 데이터를 가리키는 것이 `ESP`라는 녀석이다.



<br>



그럼 스택은 왜 쓰는가. c언어로 예를 들면

```c
void function_1()
{
  fuction_2()
}

void function_2()
{
  code
}

int main()
{
  function_1();
  function_2()
  return 0;
}
```



<br>



컴퓨터는 위와 같은 코드에서 함수에 대한 정보를 넣고 실행한다.

즉 `main -> push func_1 -> push func_2 -> pop func_2 -> pop func_1 -> push func_2 -> pop func2` 순서대로 실행을 할 때마다 스택을 이용해서 프로그램이 돌아간다. 

어셈블리어에서도 이런 함수 호출 방식에 맞추어 스택을 활용하면 된다.



<br>



### 스택의 공간 확보하기  rsp

`sub rsp, 64` 라는 명령어는 rsp에서 64만큼을 빼준다는 것을 의미한다.

여기서 rsp는 스택을 가리키는 포인터이고, 여기서 64를 뺀다는 의미는 64 만큼의 공간을 확보하겠다는 것을 의미한다.



<br>



어셈블리어에서 어떤 함수가 있다고 하면, 함수의 호출은 어떻게 하고 함수의 종료 부분은 어떻게 알릴까?

바로 `call, ret`를 사용하여 알릴 수 있다. 



<br>



## MOVS, MOVSB, SI, DI



`MOVS`는 문자열에서 문자열로(String to String) 데이터를 이동시킬 때 사용한다.

이 때 알아야 할 개념으로 SI와 DI가 있다.

SI는 Source Index의 약자로, 우리는 출발지점이라는 의미로 사용할 것이다.

DI는 Destination Index의 약자로, 우리는 목적지점이라는 의미로 사용할 것이다.



<br>



그러니까 MOVS는 SI 문자열 시작점이 있고, DI 문자열 시작점이 있으면 SI 메모리 공간에서 DI 메모리 공간으로 이동시킨다는 것을 의미한다.

사용법은 MOVS operand1, operand2이다. operand는 메모리 주소가 올 수 있다.

또한, movs rsi, rdi를 사용하여 실행할 수도 있다.







MOVSB는 MOVS + `Byte`이다. 즉 c언어의 char에 해당하는 1byte만큼 movs하겠다는 뜻이다.

(참고로 movsb 외에도 movsw(word), movsd(double word) 등이 있다.)

당연히 실행 이후에는 esi와 edi 또한 하나씩 증가한다. 



<br>



`ft_write`(rdi, rsi, rdx)

rax(syscall) -> `ft_read`(rdi, rsi, rdx)

`ft_strlen`(rdi) -> rax

`ft_strcpy`(rdi = dest, rsi = src) -> rax

`ft_strdup`(rdi) -> rax

`ft_strcmp`(rdi, rsi) -> rax

